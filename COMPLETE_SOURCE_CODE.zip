# Complete Bot Source Code Package

## 1. main.py
```python
import os
import logging
import asyncio
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters
from bot_handlers import BotHandlers
from database import Database
from config import Config

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def main():
    """Main function to start the bot"""
    try:
        # Initialize database
        db = Database()
        db.init_db()
        
        # Initialize bot handlers
        bot_handlers = BotHandlers(db)
        
        # Create application
        application = Application.builder().token(Config.BOT_TOKEN).build()
        
        # Add handlers
        application.add_handler(CommandHandler("start", bot_handlers.start_command))
        application.add_handler(CommandHandler("admin", bot_handlers.admin_command))
        application.add_handler(CommandHandler("upload", bot_handlers.upload_command))
        application.add_handler(CommandHandler("bulkupload", bot_handlers.bulk_upload_command))
        application.add_handler(CommandHandler("structure", bot_handlers.structure_command))
        application.add_handler(CommandHandler("adminchat", bot_handlers.adminchat_command))
        application.add_handler(CommandHandler("blueprint", bot_handlers.blueprint_command))
        application.add_handler(CommandHandler("verify", bot_handlers.verify_command))
        application.add_handler(CommandHandler("help", bot_handlers.help_command))
        application.add_handler(CommandHandler("stats", bot_handlers.stats_command))
        
        # Message handlers
        application.add_handler(MessageHandler(
            filters.TEXT & ~filters.COMMAND, 
            bot_handlers.handle_message
        ))
        application.add_handler(MessageHandler(
            filters.Document.ALL | filters.VIDEO, 
            bot_handlers.handle_file_upload
        ))
        
        # Callback query handler for buttons
        application.add_handler(CallbackQueryHandler(bot_handlers.handle_callback))
        
        logger.info("Starting Telegram Movie Bot...")
        
        # Start the bot  
        logger.info("Bot is starting...")
        application.run_polling(allowed_updates=['message', 'callback_query'])
        
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        raise

if __name__ == "__main__":
    main()
```

## 2. config.py
```python
import os

class Config:
    """Configuration class for the Telegram Movie Bot"""
    
    # Bot configuration
    BOT_TOKEN = os.getenv("BOT_TOKEN", "")
    
    # Admin configuration
    ADMIN_IDS = [
        int(admin_id.strip()) 
        for admin_id in os.getenv("ADMIN_IDS", "").split(",") 
        if admin_id.strip().isdigit()
    ]
    
    # URL shortener configuration
    INSHORT_API_KEY = os.getenv("INSHORT_API_KEY", "")
    INSHORT_API_TOKEN = os.getenv("INSHORT_API_TOKEN", "")
    INSHORT_API_URL = "https://inshorturl.com/api"
    
    # File configuration
    MAX_FILE_SIZE = None  # No file size limit
    ALLOWED_FILE_EXTENSIONS = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.mp3', '.wav', '.pdf', '.txt', '.zip', '.rar']
    
    # Auto-delete configuration
    AUTO_DELETE_MINUTES = 10
    
    # Database configuration
    DATABASE_PATH = "movie_bot.db"
    
    # Search configuration
    FUZZY_SEARCH_THRESHOLD = 60  # Minimum similarity percentage
    MAX_SEARCH_RESULTS = 10
    
    # Rate limiting
    MAX_SEARCHES_PER_MINUTE = 10
    MAX_UPLOADS_PER_HOUR = 1000
    BULK_UPLOAD_DELAY = 0.5
    MAX_CONCURRENT_UPLOADS = 5
    
    # Channel configuration
    BACKUP_CHANNEL = "https://t.me/your_backup_channel"
    BACKUP_CHANNEL_ID = "@your_backup_channel"
    FORCE_JOIN_BACKUP = False
    
    # Messages
    WELCOME_MESSAGE = """
ðŸŽ¬ **Welcome to Movie Filter Bot!**

**For Users:**
â€¢ Search for movies/series by typing the name
â€¢ I'll find matches even with spelling mistakes
â€¢ Click on buttons to get direct download links
â€¢ Files will be sent to your DM instantly

**Commands:**
/help - Show this help message

**Note:** This bot is for educational purposes only.
"""
    
    ADMIN_WELCOME_MESSAGE = """
ðŸ” **Admin Panel**

**Commands:**
/upload - Upload a new movie/series
/stats - View bot statistics
/admin - Show admin commands

**Upload Format:**
Send a file with caption in format:
`Movie Name | Year | Quality | Part/Season/Episode`

Example: `Avengers Endgame | 2019 | 1080p | Part 1`
"""
    
    HELP_MESSAGE = """
ðŸ†˜ **Help & Instructions**

**How to search:**
1. Type the movie/series name
2. I'll show matching results with buttons
3. Click on the button to get the file
4. File will be sent to your DM

**Search Tips:**
â€¢ You can make spelling mistakes, I'll still find it!
â€¢ Use keywords like "avengers", "season 1", "part 2"
â€¢ Be specific for better results

**Note:** Files are automatically deleted after 10 minutes for copyright protection.
"""
    
    @classmethod
    def validate_config(cls) -> bool:
        """Validate that all required configuration is present"""
        if not cls.BOT_TOKEN:
            raise ValueError("BOT_TOKEN is required")
        if not cls.ADMIN_IDS:
            raise ValueError("At least one ADMIN_ID is required")
        return True
```

## 3. utils.py
```python
import re
from typing import Dict, Optional, List
from fuzzywuzzy import fuzz

def parse_upload_caption(caption: str) -> Optional[Dict]:
    """Parse upload caption in format: Title | Year | Quality | Part"""
    if not caption or '|' not in caption:
        return None
    
    parts = [part.strip() for part in caption.split('|')]
    
    if len(parts) < 2:
        return None
    
    return {
        'title': parts[0] if len(parts) > 0 else "",
        'year': int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else None,
        'quality': parts[2] if len(parts) > 2 else "HD",
        'part_season_episode': parts[3] if len(parts) > 3 else "Complete"
    }

def extract_movie_info_from_filename(filename: str) -> Dict:
    """Extract movie information from filename"""
    # Remove extension
    name = re.sub(r'\.[^.]+$', '', filename)
    
    # Common patterns
    year_match = re.search(r'\b(19|20)\d{2}\b', name)
    quality_match = re.search(r'\b(1080p|720p|480p|4K|HD|CAM|TS|TC|HDRip|BRRip|DVDRip|WEBRip)\b', name, re.IGNORECASE)
    
    # Extract year
    year = int(year_match.group()) if year_match else None
    
    # Extract quality
    quality = quality_match.group() if quality_match else "HD"
    
    # Clean title (remove year, quality, and common tags)
    title = name
    if year_match:
        title = title.replace(year_match.group(), '')
    if quality_match:
        title = title.replace(quality_match.group(), '')
    
    # Clean up title
    title = re.sub(r'[._\-]+', ' ', title)
    title = re.sub(r'\s+', ' ', title).strip()
    
    return {
        'title': title or filename,
        'year': year,
        'quality': quality,
        'part_season_episode': "Complete"
    }

def format_file_size(size_bytes: int) -> str:
    """Format file size in human readable format"""
    if size_bytes == 0:
        return "0 B"
    
    size_names = ["B", "KB", "MB", "GB", "TB"]
    i = 0
    size = float(size_bytes)
    
    while size >= 1024.0 and i < len(size_names) - 1:
        size /= 1024.0
        i += 1
    
    return f"{size:.1f} {size_names[i]}"

def format_duration(seconds: int) -> str:
    """Format duration in human readable format"""
    if seconds < 60:
        return f"{seconds} seconds"
    elif seconds < 3600:
        minutes = seconds // 60
        return f"{minutes} minutes"
    else:
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        return f"{hours}h {minutes}m"

def fuzzy_search_movies(query: str, movies: List[Dict], threshold: int = 60) -> List[Dict]:
    """Perform fuzzy search on movies list"""
    if not movies:
        return []
    
    scored_movies = []
    query_lower = query.lower()
    
    for movie in movies:
        # Calculate similarity scores
        title_score = fuzz.partial_ratio(query_lower, movie['title'].lower())
        quality_score = fuzz.partial_ratio(query_lower, movie['quality'].lower())
        part_score = fuzz.partial_ratio(query_lower, movie['part_season_episode'].lower())
        
        # Take the highest score
        max_score = max(title_score, quality_score, part_score)
        
        if max_score >= threshold:
            scored_movies.append((movie, max_score))
    
    # Sort by score (highest first)
    scored_movies.sort(key=lambda x: x[1], reverse=True)
    
    return [movie for movie, score in scored_movies]
```

à¤‡à¤¸ à¤¤à¤°à¤¹ à¤†à¤ª à¤‡à¤¨ à¤¸à¤­à¥€ files à¤•à¥‹ copy à¤•à¤°à¤•à¥‡ exact same bot à¤¬à¤¨à¤¾ à¤¸à¤•à¤¤à¥‡ à¤¹à¥ˆà¤‚à¥¤ à¤¸à¤­à¥€ core functionality, database structure, à¤”à¤° features included à¤¹à¥ˆà¤‚à¥¤